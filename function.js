// Объекты
_.has('объект', 'массив или строка') // 'one.two.three' или ['one', 'two', 'three'] проверяет есть ли ключ в объекте,
_.get('объект', 'массив или строка', 'дефолтное значение') // проверяет есть ли ключ в объекте как и has

var object = { 'a': 1, 'b': '2', 'c': 3 };
 _.pick(object, ['a', 'c']); // => { 'a': 1, 'c': 3 } // создает объект из выбранных свойств объекта
 JSON.stringify(obj) // позволяет напечатать результат если вложенность больше 2х

 Object.assign(obj1, obj2) // выполняет слияние 2х объекстов, только поверхностно, без вложенностей
const result = {...obj1, obj2} // 3 точки это српед оператор, создает новый объект =>
 // => сливая и копируя из старых инфу, приоретет у объектов справа
 _.merge(array1, array2) // сливает с помощью lodash

 const keys = Object.keys(obj); // [ 'name', 'slug' ] - извлекает ключи из объекта и создает массив
 const values = Object.values(obj); // - извлекает значения из объекта и создает массив
const course = { name: 'JS: React', slug: 'js-react' };
const entries = Object.entries(obj); // [[ 'name', 'JS: React' ], [ 'slug', 'js-react' ]] и значения и ключи, получаем массив массивов

obj.hasOwnProperty('имя элемента') // возвращает  true / false проверяет есть ли этот элемент в объекте, лучше использовать _.has!

_.clone(obj) // клонирует/делает покию объекта (поверхностно, без вложений)
_.cloneDeep() // клонирует/делает кокию объекта (углубленно, влияет на производительность!)

const obj = {name: 'Vasya', age: 5}
const { name, ageVasay: age} = obj // => console.log(name) => 'Vasya'это диструктуризация, создает константу из объекта, 
//также можно менять название (изменил завание константы с возрастом), 

// разное
string.split('Элемент по которому делим') // .split перезаписывает строку в массив деля ее на части
string.slice() // метод обрезает элементы массива, может обрезать строку и т.д
sring.sort() // функция высшего порядка, принимает в себя функции и возвращает их, сортируя

// массив
_.intersection(friends1, friends2) // сравнивает 2 массива и возвращает 1 массив с одинаковыми элементами в friends1 и friends2 
.push('Array') //- добавление в конец массива
.pop('array') //- используется для извлечения поледнего элемента СТЕКА 
.unshift('array')// - добавление в начало массива
_.sum() // возвращает сумму элементов массива
_.last() // извлекает последний элемент массива
_.includes([1, 2, 3], 1) // => true // Проверяет есть ли элемент в массиве
.flat(depth) // возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты" на указанный уровень depth.

const friends1 = ['vasya', 'kolya', 'petya'];
const friends2 = ['igor', 'petya', 'sergey', 'vasya', 'sasha'];
_.union(friends1, friends2); // ['vasya', 'kolya', 'petya', 'igor', 'sergey', 'sasha'] - объединяет без повторений

const friends1 = ['vasya', 'kolya', 'petya'];
const friends2 = ['igor', 'petya', 'sergey', 'vasya', 'sasha'];
_.difference(friends1, friends2); // ['kolya'] - ищет разность и выводит массив

array1.concat(array2) // сливает 2 массива в 1
const newArray = [...array1, ...array2] // лучше вот так сливать конечно


